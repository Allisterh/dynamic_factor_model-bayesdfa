# DFA trend-climate regression example

```{r, message=FALSE, warning=FALSE}
library(bayesdfa)
library(assertthat)
library(rstanarm)
library(dplyr)
# cli <- read.csv("inst/SCC_BiologyEnvTrends.csv", 
#   stringsAsFactors = TRUE, strip.white = TRUE)
dfa <- readRDS("~/Downloads/GOA_biol_77.rds") # change this
library(ggplot2)
theme_set(theme_bw())

cli2 <- read.csv("../inst/SCC_BiologyEnvTrends.csv", 
  stringsAsFactors = TRUE, strip.white = TRUE)
```

```{r}
dfa$summary
m <- dfa$best_model
```

```{r rotate, cache=TRUE}
rot <- rotate_trends(m)
plot_trends(rot)
dim(rot$trends)
matplot(t(rot$trends[1:50,1,]), type = "l", col = "#00000030", lty = 1)
matplot(t(rot$trends[1:50,2,]), type = "l", col = "#00000030", lty = 1)
matplot(t(rot$trends[1:50,3,]), type = "l", col = "#00000030", lty = 1)
matplot(t(rot$trends[1:50,4,]), type = "l", col = "#00000030", lty = 1)
```

```{r}
names(cli2)
years <- as.numeric(colnames(dfa$best_model$data))
cli_dat <- select(cli2, Year, PDO)
cli_dat <- filter(cli_dat, Year %in% years) %>%
  mutate(PDO = arm::rescale(PDO)) # we may or may not want to rescale the predictors like this
sd(cli_dat$PDO)
```

The following function fits Bayesian linear regressions predicting a DFA trend based on a climate protector. It cycles through 50 (or some other number) of samples from the DFA posterior.

```{r, message=FALSE, results='hide'}
trend_lm <- function(rotated_modelfit,
  all_years, selected_years,
  climate_dat = cli_dat,
  predictor = "PDO",
  trend_number = 1, samples = 50, 
  ITER = 1000, CHAINS = 1, n_eff = 50, rhat = 1.1, show_plot = TRUE) {
  
  total_mcmc <- dim(rotated_modelfit$trends)[1]
  draws <- sample(seq_len(total_mcmc), samples)
  
  yrs_i <- which(all_years %in% selected_years)
  climate_dat <- dplyr::filter(climate_dat, Year %in% selected_years)
  formula <- as.formula(paste("dfa_trend_draw ~", predictor))
  
  post <- list()
  for (i in seq_along(draws)) {
    dd <- data.frame(climate_dat, 
      dfa_trend_draw = rotated_modelfit$trends[draws[i], trend_number, yrs_i])
    m_temp <- stan_glm(formula, data = dd, 
      iter = ITER, chains = CHAINS,
      prior = normal(0, 2, autoscale = FALSE),
      prior_intercept = normal(0, 10, autoscale = FALSE),
      prior_aux = student_t(df = 3, 0, 5, autoscale = FALSE))
    assert_that(all(m_temp$stan_summary[,"Rhat"] < rhat))
    assert_that(all(m_temp$stan_summary[,"n_eff"] > n_eff))
    post[[i]] <- as.data.frame(as.matrix(m_temp))
  }
  post_all <- dplyr::bind_rows(post)
  
  if (show_plot) {
    par(mfrow = c(1, 2))
    plot(post_all[,predictor], type = "l", col = "#00000080", lwd = 0.5)
    abline(v = seq(0, ITER * length(draws), ITER), col = "#FF000050")
    plot(density(post_all[,predictor]))
    abline(v = 0, col = "#00000050")
  }
  invisible(post_all)
}
```

Let's start by fitting our regression models to all years at once.

```{r eg1, message=FALSE, results='hide', warning=FALSE, cache=TRUE}
set.seed(1) 
m1 <- trend_lm(rot, trend_number = 1, all_years = years, selected_years = years)
m2 <- trend_lm(rot, trend_number = 2, all_years = years, selected_years = years)
m3 <- trend_lm(rot, trend_number = 3, all_years = years, selected_years = years)
m4 <- trend_lm(rot, trend_number = 4, all_years = years, selected_years = years)
```

You can access the posterior draws like this.

```{r}
head(m1)
hist(m1$PDO)
```

Now let's try just fitting the models to portions of the data:

```{r eg2, message=FALSE, results='hide', warning=FALSE, cache=TRUE}
set.seed(1)
m1_part1 <- trend_lm(rot, trend_number = 1, all_years = years, selected_years = 1977:1988)
m2_part1 <- trend_lm(rot, trend_number = 2, all_years = years, selected_years = 1977:1988)
m3_part1 <- trend_lm(rot, trend_number = 3, all_years = years, selected_years = 1977:1988)
m4_part1 <- trend_lm(rot, trend_number = 4, all_years = years, selected_years = 1977:1988)
```

```{r eg3, message=FALSE, results='hide', warning=FALSE, cache=TRUE}
set.seed(1)
m1_part2 <- trend_lm(rot, trend_number = 1, all_years = years, selected_years = 1989:2013)
m2_part2 <- trend_lm(rot, trend_number = 2, all_years = years, selected_years = 1989:2013)
m3_part2 <- trend_lm(rot, trend_number = 3, all_years = years, selected_years = 1989:2013)
m4_part2 <- trend_lm(rot, trend_number = 4, all_years = years, selected_years = 1989:2013)
```

E.g.:

```{r}
hist(m3_part2$PDO)
```

We need to extract the original DFA trends for plotting:

```{r}
n_ts <- dim(rot$Z_rot)[2]
n_trends <- dim(rot$Z_rot)[3]
n_years <- dim(rot$trends_mean)[2]
# convert to df for ggplot
df <- data.frame(
  mean_dfa = c(t(rot$trends_mean)),
  lo_dfa = c(t(rot$trends_lower)),
  hi_dfa = c(t(rot$trends_upper)),
  trend = paste0("Trend ", sort(rep(seq_len(n_trends), n_years))),
  time = rep(years, n_trends), stringsAsFactors = FALSE)
```

Now let's try predicting the last 3 years. We will write a little function to make this easier. It will return the median and 95% credible intervals on the prediction. By default I am including the observation error on the predictions.

```{r}
predict_reg_dfa <- function(covariate, model_output, covariate_name, 
  include_sigma = TRUE) {
  
  b0 <- model_output$`(Intercept)`
  b1 <- model_output[, covariate_name]
  sigma <- model_output$sigma
  if (!include_sigma) sigma <- 0
  pred <- plyr::laply(covariate, function(x) 
    rnorm(length(b0), b0 + b1 * x, sd = sigma))
  out <- data.frame(est = apply(pred, 1, median))
  out$lwr <- apply(pred, 1, quantile, probs = 0.025)
  out$upr <- apply(pred, 1, quantile, probs = 0.975)
  out
}
```

Let's run our prediction function:

```{r}
pred_clim <- filter(cli2, Year %in% 1989:2016)
fits <- list(m1_part2, m2_part2, m3_part2, m4_part2)
names(fits) <- paste("Trend", 1:4)
p <- plyr::ldply(fits, function(x) predict_reg_dfa(pred_clim$PDO, x, "PDO"))
names(p)[1] <- "trend"
p$time <- rep(pred_clim$Year, 4)
```

Let's combine the predictions with the original trends and plot them:

```{r}
p_plot <- left_join(df, p, by = c("trend", "time"))
p_plot <- mutate(p_plot, forecast = time >= 2014)
ggplot(p_plot, aes(time, mean_dfa)) + 
  geom_line(lty = 2) +
  facet_wrap(~trend) +
  geom_ribbon(aes(ymin = lwr, ymax = upr, fill = forecast), alpha = 0.2) +
  geom_line(aes(y = est, colour = forecast)) + 
  ylab("DFA trend value")
```

In the above, the dashed line represents the 'true' DFA mean value. I am not showing the credible interval on the DFA trend, although we could. The red portion represents the data the regression is fit to. The blue portion represents the forecasted portion for the last 3 years.

Alternatively, we can exclude the observation error component of the prediction. These would be our predictions of the future mean value, not our predictions of the future observed values. These should be a little bit tighter.

Let's do the same but from the regression from the earlier part of the timeseries:

```{r}
pred_clim <- filter(cli2, Year %in% c(1977:1988, 2014:2016))
fits <- list(m1_part1, m2_part1, m3_part1, m4_part1)
names(fits) <- paste("Trend", 1:4)
p <- plyr::ldply(fits, function(x) predict_reg_dfa(pred_clim$PDO, x, "PDO"))
names(p)[1] <- "trend"
p$time <- rep(pred_clim$Year, 4)
```

Let's combine the predictions with the original trends and plot them:

```{r}
p_plot <- left_join(df, p, by = c("trend", "time"))
p_plot <- mutate(p_plot, forecast = time >= 2014)
ggplot(p_plot, aes(time, mean_dfa)) + 
  geom_line(lty = 2) +
  facet_wrap(~trend) +
  geom_ribbon(aes(ymin = lwr, ymax = upr, fill = forecast), alpha = 0.2) +
  geom_line(aes(y = est, colour = forecast)) + 
  ylab("DFA trend value")
```
