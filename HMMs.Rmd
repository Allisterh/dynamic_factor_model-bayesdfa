---
title: "HMM models for regime shifts in Stan"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(ggplot2)
library(knitr)
library(depmixS4)
```

## Background

Like change point models, HMMs in Stan involve marginalizing over discrete latent states. Original code for doing HMMs was posted to the Stan-users group [here](https://groups.google.com/d/msg/stan-users/Uxs7fPW0Lks/o2z69EAElAcJ).

## Simulation

### Generating data -- 2 state model

```{r datagen}
set.seed(123)
N = 1   # Num timeseries.
T = 30     # Length of timeseries.
p0 = 0.5   # Initial prob state=1
# matrix of transition probabilities for 2 -state model
# 80% chance of staying in state 1 | in state 1
# 20% chance of changing 1 -> 2
# 30% chance of changing 2 -> 1
# 70% chance of remaining in state 2
TP = matrix(c(0.8, 0.2, 0.3, 0.7), nrow = 2, byrow = TRUE)

# Likelihood function parameters.
mu = c(2, 5) # means of 2 states
sig = c(1, 1) # sds of 2 states

# Initialise state and data structures.
X = rep(NA, N * T)
dim(X) = c(N, T)    # True state.
Y = X              # Data.

# Fill first column.
X[, 1] = sample(c(1, 2),
replace = TRUE,
prob = c(p0, 1 - p0),
size = N)

# Fill subsequent columns.
for (t in 2:T) {
for (i in 1:N) {
X[i, t] = sample(c(1, 2), size = 1, prob = TP[X[i, t - 1], ])
}
}

# Generate data from a normal distribution
for (t in 1:T) {
for (i in 1:N) {
Y[i, t] = rnorm(1, mu[X[i, t]], sig[X[i, t]])
}
}

```

\break  
  
```{r fig1, echo=FALSE, fig.cap="Plot of data and hidden states"}
df = data.frame("Time"=seq(1,length(Y[1,])), "Y" = Y[1,], "State"=as.factor(X[1,]))
ggplot(df, aes(Time, Y)) + geom_line() + geom_point(data=df, aes(color=State))
```

### Fitting the model

```{r fit, warning=FALSE, message=FALSE}
stan.data<-list(K=2,N=N,T=T,y=Y)

fitted_model = stan("hmm_original.stan", data=stan.data,iter=2000,chains=1)
pars = extract(fitted_model)
```

\break  
  
### Plotting output

The HMM estimates posterior probabilities of each state at each point in time. 

```{r fig2, echo=FALSE, fig.cap="Plot of data and hidden states"}
df$estimate = apply(pars$prob_grp[,1,], 2, mean)
ggplot(df, aes(Time, Y)) + geom_line() + geom_point(data=df, aes(color=estimate))
```

### Potential other modifications
  This 2-state model is extremely flexible, and could be modified to include (1) shared variance or not, (2) covariates on state probabilities, (3) non-gaussian errors
  
## Fitting HMMs in other packages
One of the downsides of the approach above is that coding beyond the 2-state model becomes difficult. 

As another option, we might be able to use `depmixS4` in R. 

```{r}
model_selection = data.frame("states"=1:5, "aic"=NA)

for(states in unique(model_selection$states)) {

  d = data.frame(Y = Y[1, ])
  HMM <- depmixS4::depmix(list(Y ~ 1), data = d,
  nstates = states, family = list(gaussian()))
  fitted_model = depmixS4::fit(HMM, verbose = FALSE)
  
  model_selection$aic[states] = AIC(fitted_model)
}

model_selection$delta_aic = round(model_selection$aic - min(model_selection$aic), 2)

kable(model_selection[,c("states","delta_aic")])
```

